import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;

public class ProcessNode  {
    int pid;                    
    int myPort;                 
    volatile int bossId = -1;   
    volatile boolean running = true;
    volatile boolean election = false;

    ServerSocket serverSocket;  
    ExecutorService threadPool = Executors.newCachedThreadPool();
    Map<Integer, String> processTable = new ConcurrentHashMap<>();
    Map<Integer, Long> lastHeartbeat = new ConcurrentHashMap<>();

    public ProcessNode(int myPort) {
        this.pid = new Random().nextInt(10000); // pid สุ่ม 0-9999
        this.myPort = myPort;
    }

    // ---------------- THREADS ----------------
    class Listener extends Thread {
        public void run() {
            try {
                serverSocket = new ServerSocket(myPort);
                System.out.println("Listening on port " + myPort);
                while (running) {
                    Socket s = serverSocket.accept();
                    System.out.println("Connected with " + s.getInetAddress() + " " + s.getPort());
                    threadPool.submit(() -> {
                        try (BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()))) {
                            String msg;
                            while ((msg = in.readLine()) != null) {
                                if (msg.startsWith("HEARTBEAT:")) {
                                    int fromPid = Integer.parseInt(msg.split(":")[1]);
                                    lastHeartbeat.put(fromPid, System.currentTimeMillis());
                                    System.out.println("[P" + pid + "] Received HEARTBEAT from P" + fromPid);
                                } 
                                else if (msg.startsWith("ELECTION:")) {
                                    String[] parts = msg.split(":", 3);
                                    int origin = Integer.parseInt(parts[1]);
                                    String candidateStr = parts[2].replaceAll("[\\[\\] ]", "");
                                    Set<Integer> candidates = new HashSet<>();
                                    if (!candidateStr.isEmpty()) {
                                        for (String c : candidateStr.split(",")) {
                                            candidates.add(Integer.parseInt(c.trim()));
                                        }
                                    }
                                    forwardElection(origin, candidates);
                                } 
                                else if (msg.startsWith("COORDINATOR:")) {
                                    int newBoss = Integer.parseInt(msg.split(":")[1]);
                                    bossId = newBoss;
                                    election = false;
                                    System.out.println("[P" + pid + "] New Leader is P" + newBoss);
                                }
                                
                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    });
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    class HeartbeatSender extends Thread {
        public void run() {
            while (running) {
                System.out.println("[P" + pid + "] Sent HEARTBEAT");

                for (Map.Entry<Integer, String> entry : processTable.entrySet()) {
                    int targetPid = entry.getKey();
                    if (targetPid == pid)
                        continue;

                    String[] ipPort = entry.getValue().split(":");
                    String ip = ipPort[0];
                    int port = Integer.parseInt(ipPort[1]);

                    System.out.println("[P" + pid + "] Sending heartbeat to P" + targetPid);

                    try (Socket socket = new Socket(ip, port);
                         PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                        out.println("HEARTBEAT:" + pid);
                    } catch (IOException e) {
                        System.out.println("[P" + pid + "] Failed to send heartbeat to P" + targetPid);
                    }
                }

                try {
                    Thread.sleep(1000); // ส่ง heartbeat ทุก 1 วินาที
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    class FailureDetector extends Thread {
        public void run() {
            while (running) {
                long now = System.currentTimeMillis();
                for (Integer p : new HashSet<>(lastHeartbeat.keySet())) {
                    if (now - lastHeartbeat.get(p) > 20000) { // timeout 20 วิ
                        System.out.println("Process " + p + " failed!");
                        lastHeartbeat.remove(p);
                        if (!election) {
                            startElection();
                        }
                    }
                }
                try { Thread.sleep(5000); } catch (InterruptedException e) {}
            }
        }
    }

    // ---------------- ELECTION ----------------
    void startElection() {
        election = true;
        Set<Integer> candidates = new HashSet<>();
        candidates.add(pid);

        ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
        Collections.sort(ids);

        int index = ids.indexOf(pid);
        int nextIndex = (index + 1) % ids.size();
        int nextPid = ids.get(nextIndex);

        System.out.println("[P" + pid + "] Starting election | Candidates: " + candidates);
        sendElection(nextPid, pid, candidates);
    }

    void forwardElection(int origin, Set<Integer> candidates) {
        candidates.add(pid);

        ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
        Collections.sort(ids);

        int index = ids.indexOf(pid);
        int nextIndex = (index + 1) % ids.size();
        int nextPid = ids.get(nextIndex);

        System.out.println("[P" + pid + "] Forwarding ELECTION | Candidates: " + candidates);

        if (nextPid == origin) {
            int boss = Collections.max(candidates); 
            this.bossId = boss;
            this.election = false;
            System.out.println("[P" + pid + "] Leader Elected: P" + boss);
            sendCoordinator(boss);
            return;
        }

        sendElection(nextPid, origin, candidates);
    }

    void sendElection(int targetPid, int origin, Set<Integer> candidates) {
        String address = processTable.get(targetPid);
        if (address == null) return;

        String[] split = address.split(":");
        String host = split[0];
        int port = Integer.parseInt(split[1]);

        String message = "ELECTION:" + origin + ":" + candidates.toString();
        System.out.println("[P" + pid + "] Sending ELECTION to P" + targetPid + " | Candidates: " + candidates);

        try (Socket socket = new Socket(host, port);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
            out.println(message);
        } catch (IOException e) {
            System.err.println("[P" + pid + "] Failed to send ELECTION to P" + targetPid);
        }
    }

    void sendCoordinator(int boss) {
        String message = "COORDINATOR:" + boss;
        System.out.println("[P" + pid + "] Announcing Leader: P" + boss + " to all processes");
        broadcastMessage(message);
    }

    void broadcastMessage(String msg) {
        for (int targetPid : processTable.keySet()) {
            if (targetPid == pid) continue;

            String address = processTable.get(targetPid);
            if (address == null) continue;

            String[] split = address.split(":");
            String host = split[0];
            int port = Integer.parseInt(split[1]);
            try (Socket socket = new Socket(host, port);
                 PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                out.println(msg);
            } catch (IOException e) {
                System.err.println("[P" + pid + "] Failed to broadcast to P" + targetPid);
            }
        }
    }

    // ---------------- MAIN ----------------
    public static void main(String[] args) {
        int myPort = Integer.parseInt(args[0]);

        ProcessStruct node = new ProcessStruct(myPort);
        node.processTable.put(node.pid, Integer.toString(myPort));

        new Thread(node.new HeartbeatSender()).start();
        new Thread(node.new FailureDetector()).start();
        new Thread(node.new Listener()).start();

        System.out.println("Process " + node.pid + " started at port " + myPort);
    }
}
