import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ProcessNode {
    int pid;
    int myPort;
    volatile int bossId = -1;
    volatile boolean running = true;
    volatile boolean election = false;

    ServerSocket serverSocket;
    ExecutorService threadPool = Executors.newCachedThreadPool();
    Map<Integer, String> processTable = new ConcurrentHashMap<>();
    Map<Integer, Long> lastHeartbeat = new ConcurrentHashMap<>();

    public ProcessNode(int myPort) {
        this.pid = new Random().nextInt(10000); // pid สุ่ม 0-9999
        this.myPort = myPort;
    }

    // ---------------- THREADS ----------------
    class Listener extends Thread {
        public void run() {
            try {
                serverSocket = new ServerSocket(myPort);
                System.out.println("Listening on port " + myPort);
                while (running) {
                    Socket s = serverSocket.accept();
                    System.out.println("Connected with " + s.getInetAddress() + " " + s.getPort());
                    threadPool.submit(() -> {
                        try (BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()))) {
                            String msg;
                            while ((msg = in.readLine()) != null) {
                                FailureDetector fd = new FailureDetector();
                                if (msg.startsWith("HEARTBEAT:")) {
                                    int sender = Integer.parseInt(msg.split(":")[1]);
                                    lastHeartbeat.put(sender, System.currentTimeMillis());
                                    System.out.println("receive heartbeat From " + sender);
                                }

                                else if (msg.startsWith("ELECTION:")) {
                                    int sender = Integer.parseInt(msg.split(":")[1]);
                                    System.out.println("receive election From " + sender);
                                    ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
                                    int index = ids.indexOf(pid);
                                    int nextIndex = (index + 1) % ids.size();
                                    int nextP = ids.get(nextIndex);
                                    sendElection(nextP, msg.split(":")[0] + msg.split(":")[2]);
                                }

                                else if (msg.startsWith("COORDINATOR:")) {
                                    election = false;
                                    bossId = Integer.parseInt(msg.split(":")[1]);
                                    fd.sendCoordinator(bossId);
                                    System.out.println("New boss is " + bossId);
                                }
                            }
                        } catch (IOException e) {
                            if (running) {
                                System.err.println("Error accepting connection: ");
                                e.printStackTrace();
                            } else {
                                System.out.println("Server stopped accepting connections.");
                            }
                            try {
                                serverSocket.close();
                            } catch (IOException ex) {
                                ex.printStackTrace();
                            }
                        }
                    });
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    class HeartbeatSender extends Thread {
        private final int pid;
        private final Map<Integer, String> processTable;
        private volatile boolean running = true;

        HeartbeatSender(int pid, Map<Integer, String> processTable) {
            this.pid = pid;
            this.processTable = processTable;
        }

        public void run() {
            while (running) {
                
                System.out.println("Sent HEARTBEAT from P" + pid);

                for (Map.Entry<Integer, String> entry : processTable.entrySet()) {
                    int targetPid = entry.getKey();
                    if (targetPid == pid)
                        continue; 

                    String[] ipPort = entry.getValue().split(":");
                    String ip = ipPort[0];
                    int port = Integer.parseInt(ipPort[1]);

                    // แสดง log การส่ง heartbeat ไป process อื่น ๆ
                    System.out.println("[P" + pid + "]Sending heartbeat to P" + targetPid);

                    try (Socket socket = new Socket(ip, port);
                        PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                        out.println("HEARTBEAT:" + pid);
                    } catch (IOException e) {
                        System.out.println("[P" + pid + "] failed to send heartbeat to P" + targetPid);
                    }
                }

                try {
                    Thread.sleep(1000); // ส่ง heartbeat ทุก 1 วินาที
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }

        public void stopHeartbeat() {
            running = false;
        }
    }

    class FailureDetector extends Thread {
        
        // ELECTION / RING
        void startElection() {
            election = true;
            Set<Integer> candidates = new HashSet<>();
            candidates.add(pid);

            ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
            Collections.sort(ids);

            int index = ids.indexOf(pid);
            int nextIndex = (index + 1) % ids.size();
            int nextPid = ids.get(nextIndex);

            System.out.println("[P" + pid + "] Starting election | Candidates: " + candidates);
            sendElection(nextPid, pid, candidates);
        }

        void forwardElection(int origin, Set<Integer> candidates) {
            candidates.add(pid);

            ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
            Collections.sort(ids);

            int index = ids.indexOf(pid);
            int nextIndex = (index + 1) % ids.size();
            int nextPid = ids.get(nextIndex);

            System.out.println("[P" + pid + "] Forwarding ELECTION | Candidates: " + candidates);

            if (nextPid == origin) {
                int boss = Collections.max(candidates); // maxCandidates = leader
                this.bossId = boss;
                this.election = false;
                System.out.println("[P" + pid + "] Leader Elected: P" + boss);
                sendCoordinator(boss);
                return;
            }

            sendElection(nextPid, origin, candidates);
        }

        void sendElection(int targetPid, int origin, Set<Integer> candidates) {
            String address = processTable.get(targetPid);
            if (address == null)
                return;

            String[] split = address.split(":");
            String host = split[0];
            int port = Integer.parseInt(split[1]);

            String message = "ELECTION:" + origin + ":" + candidates.toString();
            System.out.println("[P" + pid + "] Sending ELECTION to P" + targetPid + " | Candidates: " + candidates);

            try (Socket socket = new Socket(host, port);
                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                out.println(message);
            } catch (IOException e) {
                System.err.println("[P" + pid + "] Failed to send ELECTION to P" + targetPid);
            }
        }

        void sendCoordinator(int boss) {
            String message = "COORDINATOR:" + boss;
            System.out.println("[P" + pid + "] Announcing Leader: P" + boss + " to all processes");
            broadcastMessage(message);
        }

        void broadcastMessage(String msg) {
            for (int targetPid : processTable.keySet()) {
                String address = processTable.get(targetPid);
                if (address == null)
                    continue;

                String[] split = address.split(":");
                String host = split[0];
                int port = Integer.parseInt(split[1]);
                try (Socket socket = new Socket(host, port);
                        PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                    out.println(msg);
                } catch (IOException e) {
                    System.err.println("[P" + pid + "] Failed to broadcast to P" + targetPid);
                }
            }
        }
    }

    void broadcastMessage(String msg) {
    }

    void startElection() {
        election = true;
        Set<Integer> processes = new HashSet<>();
        processes.add(this.pid);
        ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
        int index = ids.indexOf(pid);
        int nextIndex = (index + 1) % ids.size();
        int nextP = ids.get(nextIndex);

        sendElection(nextP, "ELECTION:" + pid + ":" + processes);
    }

    void sendElection(int pid, String message) {
        String address = processTable.get(pid);
        if (address == null) {
            return;
        }

        String[] split = address.split(":");
        if (pid == this.pid) {
            String P = split[2];
            P = P.substring(1, P.length() - 1);
            String[] temp = P.split(",");
            Set<Integer> candidate = new HashSet<>();
            for (String x : temp) {
                int num = Integer.parseInt(x);
                candidate.add(num);
            }

            int boss = Collections.max(candidate);
            this.bossId = boss;
            sentCoordinator(boss);
        }

        String host = split[0];
        int port = Integer.parseInt(split[1]);
        try (Socket socket = new Socket(host, port);
                PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
            out.println(message);
            System.out.println("Send to " + pid + ": " + message);
        } catch (IOException e) {
            System.err.println("Failed to send to " + pid);
            e.printStackTrace();
        }
    }

    void sentCoordinator(int boss) {
        String message = "COORDINATOR:" + boss;

    }

    // ---------------- MAIN ----------------
    public static void main(String[] args) {
        // args[0] = myPort
        int myPort = Integer.parseInt(args[0]);

        ProcessNode node = new ProcessNode(myPort);

        // TODO: โหลด processTable จาก config หรือ dynamic register

        new Thread(node.new HeartbeatSender()).start();
        new Thread(node.new FailureDetector()).start();
        new Thread(node.new Listener()).start();

        System.out.println("Process " + node.pid + " started at port " + myPort);
    }
}
