import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;

public class ProcessNode  {
    int pid;
    String myIP;                     
    int myPort;  
    volatile int bossId = -1;   
    volatile boolean running = true;
    volatile boolean election = false;

    ServerSocket serverSocket;  
    ExecutorService threadPool = Executors.newCachedThreadPool();
    Map<Integer, String> processTable = new ConcurrentHashMap<>();
    Map<Integer, Long> lastHeartbeat = new ConcurrentHashMap<>();

    public ProcessNode(int pid,String myIP,int myPort) {
        this.pid = pid; // สุ่มมีโอกาสซ้ำได้เดี๋ยวจะเกิดปัญหาเอา
        this.myIP = myIP;
        this.myPort = myPort;
    }

    // ---------------- THREADS ----------------
    class Listener extends Thread {
        public void run() {
            try {
                serverSocket = new ServerSocket(myPort);
                while (running) {
                    Socket s = serverSocket.accept();
                    //System.out.println("Connected with " + s.getInetAddress() + " " + s.getPort());     เนื่องจาก listener มันเปิด-ปิดๆตอนที่ได้รับข้อความทำให้มันพิมพ์อันนี้ซ้ำๆๆๆๆย้ายไปอยู่ใน sync กับ join
                    threadPool.submit(() -> {
                        try (BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()))) {
                            String msg;
                            while ((msg = in.readLine()) != null) {
                                if (msg.startsWith("HEARTBEAT:")) {
                                    int fromPid = Integer.parseInt(msg.split(":")[1]);
                                    lastHeartbeat.put(fromPid, System.currentTimeMillis());
                                    System.out.println("[P" + pid + "] Received HEARTBEAT from P" + fromPid);
                                } 
                                else if (msg.startsWith("ELECTION:")) {
                                    String[] parts = msg.split(":", 3);
                                    int origin = Integer.parseInt(parts[1]);
                                    String candidateStr = parts[2].replaceAll("[\\[\\] ]", "");
                                    Set<Integer> candidates = new HashSet<>();
                                    if (!candidateStr.isEmpty()) {
                                        for (String c : candidateStr.split(",")) {
                                            candidates.add(Integer.parseInt(c.trim()));
                                        }
                                    }
                                    forwardElection(origin, candidates);
                                } 
                                else if (msg.startsWith("COORDINATOR:")) {
                                    int newBoss = Integer.parseInt(msg.split(":")[1]);
                                    bossId = newBoss;
                                    election = false;
                                    System.out.println("[P" + pid + "] New Leader is P" + newBoss);
                                }

                                else if (msg.startsWith("JOIN:")){
                                    String[] parts = msg.split(":");
                                    int newPid = Integer.parseInt(parts[1]);
                                    String newAddress = parts[2]+":"+parts[3];

                                    processTable.put(newPid, newAddress);
                                    lastHeartbeat.put(newPid, System.currentTimeMillis());
                                    System.out.println("[P" + pid + "] added [P" + newPid + "] to Process Table.");
                                    System.out.println("Connected with [P" + newPid + "] " + newAddress);

                                    // broadcast แจ้งทุก node ว่ามีสมาชิกใหม่
                                    broadcastMessage("ADD:" + newPid + ":" + parts[2] + ":" + parts[3]);
                                    sendSync(newPid);
                                }

                                else if (msg.startsWith("SYNC:")){
                                    String IPs = msg.substring("SYNC:".length());  //"SYNC:".length() ความยาวเท่ากับ 5 เอาไว้ตัดข้อความออก
                                    String[] lotOfIPs = IPs.split("\\|"); //ฟีล escape sequences
                                    
                                    for(String x : lotOfIPs){
                                        String[] parts = x.split(":");
                                        int newPid = Integer.parseInt(parts[0]);
                                        String newAddress = parts[1] + ":" + parts[2];

                                        if(!processTable.containsKey(newPid)){
                                            processTable.put(newPid, newAddress);
                                            lastHeartbeat.put(newPid, System.currentTimeMillis());
                                            System.out.println("[P" + pid + "] added [P" + newPid + "] to Process Table.");
                                            System.out.println("Connected with [P" + newPid + "] " + newAddress);
                                        }
                                    }
                                }

                                //
                                else if (msg.startsWith("ADD:")) {
                                    String[] parts = msg.split(":");
                                    int pid = Integer.parseInt(parts[1]);
                                    String address = parts[2] + ":" + parts[3];

                                    if (!processTable.containsKey(pid)) {
                                        processTable.put(pid, address);
                                        lastHeartbeat.put(pid, System.currentTimeMillis());
                                        System.out.println("[P" + pid + "] added [P" + pid + "] via ADD " + address);
                                    }
                                }
                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    });
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    void sendSync(int targetPid){
        String address = processTable.get(targetPid);
        if(address == null){
            return;
        }

        String[] parts = address.split(":");
        String ip = parts[0];
        int port = Integer.parseInt(parts[1]);

        //กระบวนการสร้างข้อความที่จะใช้ส่ง
        StringBuilder sb = new StringBuilder("SYNC:"); //StringBuilder ใช้ในการสร้าง string
        for (Map.Entry<Integer,String> x : processTable.entrySet()) {
            //.append คือต่อท้ายลง sb
            sb.append(x.getKey()).append(":");                         //ส่วนนี้ทำของ pid
            String[] p = x.getValue().split(":");
            sb.append(p[0]).append(":").append(p[1]).append("|");  //ส่วนนี้ทำของ ip port
        }
        String msg = sb.toString();

        
        try (Socket socket = new Socket(ip, port);
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
            out.println(msg);
            System.out.println("[P" + pid + "] Sent SYNC to P" + targetPid);
        } catch (IOException e) {
            System.err.println("[P" + pid + "] Failed to send SYNC to P" + targetPid);
        }
    }

    class HeartbeatSender extends Thread {
        public void run() {
            while (running) {
                // System.out.println("[P" + pid + "] Sent HEARTBEAT"); เข้าลูปแล้วทำงานเลยอาจจะบัคตอนส่งถึงตัวอื่นจริงๆ + ซ้ำกับข้อความในลูป
                for (Map.Entry<Integer, String> entry : processTable.entrySet()) {
                    int targetPid = entry.getKey();
                    if (targetPid == pid)
                        continue;

                    String[] ipPort = entry.getValue().split(":");
                    String ip = ipPort[0];
                    int port = Integer.parseInt(ipPort[1]);

                    System.out.println("[P" + pid + "] Sending heartbeat to P" + targetPid);

                    try (Socket socket = new Socket(ip, port);
                         PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                        out.println("HEARTBEAT:" + pid);
                    } catch (IOException e) {
                        System.out.println("[P" + pid + "] Failed to send heartbeat to P" + targetPid);
                    }
                }

                try {
                    Thread.sleep(1000); // ส่ง heartbeat ทุก 1 วินาที
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    class FailureDetector extends Thread {
        public void run() {
            while (running) {
                long now = System.currentTimeMillis();
                for (Integer p : new HashSet<>(lastHeartbeat.keySet())) {
                    if (now - lastHeartbeat.get(p) > 20000) { // timeout 20 วิ
                        System.out.println("Process " + p + " failed!");
                        lastHeartbeat.remove(p);
                        if (!election) {
                            startElection();
                        }
                    }
                }
                try { Thread.sleep(5000); } catch (InterruptedException e) {}
            }
        }
    }

    // ---------------- ELECTION ----------------
    void startElection() {
        election = true;
        Set<Integer> candidates = new HashSet<>();
        candidates.add(pid);

        ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
        Collections.sort(ids);

        int index = ids.indexOf(pid);
        int nextIndex = (index + 1) % ids.size();
        int nextPid = ids.get(nextIndex);

        System.out.println("[P" + pid + "] Starting election | Candidates: " + candidates);
        sendElection(nextPid, pid, candidates);
    }

    void forwardElection(int origin, Set<Integer> candidates) {
        candidates.add(pid);

        ArrayList<Integer> ids = new ArrayList<>(processTable.keySet());
        Collections.sort(ids);

        int index = ids.indexOf(pid);
        int nextIndex = (index + 1) % ids.size();
        int nextPid = ids.get(nextIndex);

        System.out.println("[P" + pid + "] Forwarding ELECTION | Candidates: " + candidates);

        if (nextPid == origin) {
            int boss = Collections.max(candidates); 
            this.bossId = boss;
            this.election = false;
            System.out.println("[P" + pid + "] Leader Elected: P" + boss);
            sendCoordinator(boss);
            return;
        }

        sendElection(nextPid, origin, candidates);
    }

    void sendElection(int targetPid, int origin, Set<Integer> candidates) {
        String address = processTable.get(targetPid);
        if (address == null) return;

        String[] split = address.split(":");
        String host = split[0];
        int port = Integer.parseInt(split[1]);

        String message = "ELECTION:" + origin + ":" + candidates.toString();
        System.out.println("[P" + pid + "] Sending ELECTION to P" + targetPid + " | Candidates: " + candidates);

        try (Socket socket = new Socket(host, port);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
            out.println(message);
        } catch (IOException e) {
            System.err.println("[P" + pid + "] Failed to send ELECTION to P" + targetPid);
        }
    }

    void sendCoordinator(int boss) {
        String message = "COORDINATOR:" + boss;
        System.out.println("[P" + pid + "] Announcing Leader: P" + boss + " to all processes");
        broadcastMessage(message);
    }

    void broadcastMessage(String msg) {
        for (int targetPid : processTable.keySet()) {
            if (targetPid == pid) continue;

            String address = processTable.get(targetPid);
            if (address == null) continue;

            String[] split = address.split(":");
            String host = split[0];
            int port = Integer.parseInt(split[1]);
            try (Socket socket = new Socket(host, port);
                 PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                out.println(msg);
            } catch (IOException e) {
                System.err.println("[P" + pid + "] Failed to broadcast to P" + targetPid);
            }
        }
    }

    // ---------------- MAIN ----------------
    public static void main(String[] args) {
        int pid = Integer.parseInt(args[0]);
        String myIP = args[1].trim();
        int myPort = Integer.parseInt(args[2]);

        ProcessNode node = new ProcessNode(pid,myIP,myPort);
        node.processTable.put(node.pid, node.myIP +":"+Integer.toString(node.myPort));

        System.out.println("[P" + node.pid + "] started at port " + node.myPort);

        new Thread(node.new HeartbeatSender()).start();
        new Thread(node.new FailureDetector()).start();
        new Thread(node.new Listener()).start();

        if (args.length >= 5) {
            String bootstrapIP = args[3];
            int bootstrapPort = Integer.parseInt(args[4]);
            try (Socket socket = new Socket(bootstrapIP, bootstrapPort);
                PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                out.println("JOIN:" + pid + ":" + myIP + ":" + myPort);
                System.out.println("[P" + pid + "] Sent JOIN to " + bootstrapIP + ":" + bootstrapPort);
            } catch (IOException e) {
                System.err.println("[P" + pid + "] Failed to contact bootstrap node");
            }
        }
    }
}





/*
่ตัวแรก : java ProcessNode [PID] [IP] [PORT]
ตัวที่ 2-n : java Process Node [PID] [IP] [PORT] [IP ตัวก่อนหน้านี้ตัวไหนก็ได้] [PORT ตัวก่อนหน้านี้ตัวไหนก็ได้]
*/
